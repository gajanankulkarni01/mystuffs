//.h file code:

#include <string>
#include <vector>
#include <any>
#include "stringbuilder.h"

namespace Test
{
	class Test5 final
	{
	private:
//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
//ORIGINAL LINE: [flags] enum CREDUI_FLAGS
		enum class CREDUI_FLAGS
		{
			INCORRECT_PASSWORD = 0x1,
			DO_NOT_PERSIST = 0x2,
			REQUEST_ADMINISTRATOR = 0x4
		};

public:
	static bool Test6(const std::wstring &tagname, const std::wstring &captionText, const std::wstring &messageText, std::wstring &password, std::wstring &domain);

	};
}

//Helper class added by C# to C++ Converter:

//----------------------------------------------------------------------------------------
//	Copyright Â© 2004 - 2019 Tangible Software Solutions, Inc.
//	This class can be used by anyone provided that the copyright notice remains intact.
//
//	This class is used to replace the .NET StringBuilder in C++.
//----------------------------------------------------------------------------------------
#include <string>
#include <sstream>

class StringBuilder
{
private:
	std::wstring privateString;

public:
	StringBuilder()
	{
	}

	StringBuilder(const std::wstring &initialString)
	{
		privateString = initialString;
	}

	StringBuilder(std::size_t capacity)
	{
		ensureCapacity(capacity);
	}

	StringBuilder(const std::wstring &initialString, std::size_t capacity)
	{
		privateString = initialString;
		ensureCapacity(capacity);
	}

	wchar_t operator [](std::size_t index)
	{
		return privateString[index];
	}

	StringBuilder *append(const std::wstring &toAppend)
	{
		privateString += toAppend;
		return this;
	}

	template<typename T>
	StringBuilder *append(const T &toAppend)
	{
		privateString += toString(toAppend);
		return this;
	}

	StringBuilder *appendLine()
	{
		privateString += L"\r\n";
		return this;
	}

	StringBuilder *appendLine(const std::wstring &toAppend)
	{
		privateString += toAppend + L"\r\n";
		return this;
	}

	StringBuilder *insert(std::size_t position, const std::wstring &toInsert)
	{
		privateString.insert(position, toInsert);
		return this;
	}

	template<typename T>
	StringBuilder *insert(std::size_t position, const T &toInsert)
	{
		privateString.insert(position, toString(toInsert));
		return this;
	}

	std::wstring toString()
	{
		return privateString;
	}

	std::wstring toString(std::size_t start, std::size_t length)
	{
		return privateString.substr(start, length);
	}

	std::size_t length()
	{
		return privateString.length();
	}

	void setLength(std::size_t newLength)
	{
		privateString.resize(newLength);
	}

	std::size_t capacity()
	{
		return privateString.capacity();
	}

	void ensureCapacity(std::size_t minimumCapacity)
	{
		privateString.reserve(minimumCapacity);
	}

	std::size_t maxCapacity()
	{
		return privateString.max_size();
	}

	void clear()
	{
		privateString.clear();
	}

	StringBuilder *remove(std::size_t start, std::size_t length)
	{
		privateString.erase(start, length);
		return this;
	}

	StringBuilder *replace(const std::wstring &oldString, const std::wstring &newString)
	{
		std::size_t pos = 0;
		while ((pos = privateString.find(oldString, pos)) != std::wstring::npos)
		{
			privateString.replace(pos, oldString.length(), newString);
			pos += newString.length();
		}
		return this;
	}

private:
	template<typename T>
	static std::wstring toString(const T &subject)
	{
		std::wostringstream ss;
		ss << subject;
		return ss.str();
	}
};

//.cpp file code:

namespace Test
{

	bool Test5::Test6(const std::wstring &tagname, const std::wstring &captionText, const std::wstring &messageText, std::wstring &password, std::wstring &domain)
	{
		user = L"";
		password = L"";
		domain = L"";

	StringBuilder *userPassword = new StringBuilder(256), *userId = new StringBuilder(256);
	CREDUI_INFO *credUI = new CREDUI_INFO();
	credUI->size = Marshal::SizeOf(credUI);
	credUI->testcationText = captionText;
	bool save = false;

	CREDUI_FLAGS flags = CREDUI_FLAGS::ALWAYS_SHOW_UI | CREDUI_FLAGS::GENERIC_CREDENTIALS | CREDUI_FLAGS, DO_NOT_REQUEST;
	CredUIReturnCodes *returnCode = CredUIPromptForCredentials(credUI, targetName, std::any::Zero, 0, userId,256, userPassword, 256, save, flags);
	if (returnCode == CredUIReturnCodes::NO_ERROR)
	{
		user = userId->toString();
		std::vector<wchar_t> pass(userPassword->length());
		userPassword->Copy(0, pass, 0, userPassword->length());
		for (int i = 0; i < userPassword->length(); i++)
		{
			password += userPassword[i];
			userPassword[i] = L'0';
		}

	StringBuilder *tmp = new StringBuilder();
	StringBuilder *tmp1 = new StringBuilder();
	if (CredUIParseUserName(user, tmp, 256, tmp1, 256) == CredUIReturnCodes::NO_ERROR)
	{
		user = tmp->toString();
		domain = tmp1->toString();
	}

//C# TO C++ CONVERTER TODO TASK: A 'delete tmp1' statement was not added since tmp1 was passed to a method or constructor. Handle memory management manually.
//C# TO C++ CONVERTER TODO TASK: A 'delete tmp' statement was not added since tmp was passed to a method or constructor. Handle memory management manually.
	}

//C# TO C++ CONVERTER TODO TASK: A 'delete credUI' statement was not added since credUI was passed to a method or constructor. Handle memory management manually.
//C# TO C++ CONVERTER TODO TASK: A 'delete userId' statement was not added since userId was passed to a method or constructor. Handle memory management manually.
//C# TO C++ CONVERTER TODO TASK: A 'delete userPassword' statement was not added since userPassword was passed to a method or constructor. Handle memory management manually.
	return (returCode == CredUIReturnCodes::NO_ERROR);
	}
}
------------------------------------------------------------------------------------------------------------------------------------------------------------

namespace Test
{
	internal static class Test5
	{
		[flags]
		enum CREDUI_FLAGS
		{
			INCORRECT_PASSWORD = 0x1,
			DO_NOT_PERSIST = 0x2,
			REQUEST_ADMINISTRATOR = 0x4
		}
		
	internal static bool Test6(string tagname, string captionText, string messageText, out string password, out string domain)
	{
		user = "";
		password = "";
		domain = "";

	StringBuilder userPassword = new StringBuilder(256), userId = new StringBuilder(256);
	CREDUI_INFO credUI = new CREDUI_INFO();
	credUI.size= Marshal.SizeOf(credUI);
	credUI.testcationText = captionText;
	bool save = false;
	
	CREDUI_FLAGS flags = CREDUI_FLAGS.ALWAYS_SHOW_UI | CREDUI_FLAGS.GENERIC_CREDENTIALS | CREDUI_FLAGS,DO_NOT_REQUEST;
	CredUIReturnCodes returnCode = CredUIPromptForCredentials(ref credUI, targetName, IntPtr.Zero, 0, userId,256, userPassword, 256, ref save, flags);
	if(returnCode == CredUIReturnCodes.NO_ERROR)
	{
		user = userId.ToString();
		Char[] pass = new Char[userPassword.Length];
		userPassword.Copy(0, pass, 0, userPassword.Length);
		for(Int32 i = 0; i < userPassword.Length; i++)
		{
			password+= userPassword[i];
			userPassword[i] = '0';
		}

	StringBuilder tmp = new StringBuilder();
	StringBuilder tmp1 = new StringBuilder();
	if(CredUIParseUserName(user, tmp, 256, tmp1, 256) == CredUIReturnCodes.NO_ERROR)
	{
		user = tmp.ToString();
		domain = tmp1.ToString();
	}
	}
return (returCode == CredUIReturnCodes.NO_ERROR);
	}

	}
}